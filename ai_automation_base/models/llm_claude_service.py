from odoo import models, fields, api, _
from odoo.exceptions import ValidationError, UserError
import json
import logging
import requests
from typing import Dict, List, Optional, Any, Union

_logger = logging.getLogger(__name__)


class LLMClaudeService(models.Model):
    """Anthropic Claude LLM service implementation."""
    
    _name = 'llm.claude.service'
    _description = 'Anthropic Claude LLM Service'
    _inherit = 'llm.base.service'
    
    def generate_text(self, prompt: str, model: str = None, **kwargs) -> str:
        """Generate text using Anthropic Claude's messages API."""
        if not model:
            model = self.get_default_model()
        
        # Validate parameters
        validated_params = self.validate_parameters(**kwargs)
        
        # Prepare request data for Claude
        request_data = {
            'model': model,
            'max_tokens': validated_params.get('max_tokens', 1000),
            'messages': [{
                'role': 'user',
                'content': prompt
            }]
        }
        
        # Map parameters to Claude format
        if 'temperature' in validated_params:
            request_data['temperature'] = validated_params['temperature']
        if 'top_p' in validated_params:
            request_data['top_p'] = validated_params['top_p']
        if 'stop_sequences' in validated_params:
            request_data['stop_sequences'] = validated_params['stop_sequences']
        
        try:
            # Make API request
            headers = {
                'x-api-key': self.get_api_key(),
                'Content-Type': 'application/json',
                'anthropic-version': '2023-06-01',
            }
            
            response = requests.post(
                f"{self.get_base_url()}/messages",
                headers=headers,
                json=request_data,
                timeout=30
            )
            
            # Handle rate limits
            self.handle_rate_limits(response)
            
            if response.status_code == 200:
                response_data = response.json()
                
                # Extract generated text from Claude response
                if 'content' in response_data and response_data['content']:
                    generated_text = response_data['content'][0]['text'].strip()
                    
                    # Log successful request
                    self.log_request(request_data, response_data, 'success')
                    
                    return generated_text
                else:
                    raise UserError(_('No content generated by Claude'))
            else:
                error_data = response.json() if response.content else {}
                error_message = error_data.get('error', {}).get('message', f'HTTP {response.status_code}')
                
                # Log failed request
                self.log_request(request_data, error_data, 'error', error_message)
                
                raise UserError(_('Claude API error: %s') % error_message)
                
        except requests.exceptions.RequestException as e:
            error_message = f"Network error: {str(e)}"
            self.log_request(request_data, {}, 'error', error_message)
            raise UserError(_('Network error: %s') % str(e))
        except Exception as e:
            error_message = f"Unexpected error: {str(e)}"
            self.log_request(request_data, {}, 'error', error_message)
            raise UserError(_('Unexpected error: %s') % str(e))
    
    def chat_completion(self, messages: List[Dict], model: str = None, **kwargs) -> Dict:
        """Generate chat completion using Anthropic Claude's messages API."""
        if not model:
            model = self.get_default_model()
        
        # Validate parameters
        validated_params = self.validate_parameters(**kwargs)
        
        # Prepare request data
        request_data = {
            'model': model,
            'max_tokens': validated_params.get('max_tokens', 1000),
            'messages': messages
        }
        
        # Map parameters to Claude format
        if 'temperature' in validated_params:
            request_data['temperature'] = validated_params['temperature']
        if 'top_p' in validated_params:
            request_data['top_p'] = validated_params['top_p']
        if 'stop_sequences' in validated_params:
            request_data['stop_sequences'] = validated_params['stop_sequences']
        
        try:
            # Make API request
            headers = {
                'x-api-key': self.get_api_key(),
                'Content-Type': 'application/json',
                'anthropic-version': '2023-06-01',
            }
            
            response = requests.post(
                f"{self.get_base_url()}/messages",
                headers=headers,
                json=request_data,
                timeout=30
            )
            
            # Handle rate limits
            self.handle_rate_limits(response)
            
            if response.status_code == 200:
                response_data = response.json()
                
                # Log successful request
                self.log_request(request_data, response_data, 'success')
                
                return response_data
            else:
                error_data = response.json() if response.content else {}
                error_message = error_data.get('error', {}).get('message', f'HTTP {response.status_code}')
                
                # Log failed request
                self.log_request(request_data, error_data, 'error', error_message)
                
                raise UserError(_('Claude API error: %s') % error_message)
                
        except requests.exceptions.RequestException as e:
            error_message = f"Network error: {str(e)}"
            self.log_request(request_data, {}, 'error', error_message)
            raise UserError(_('Network error: %s') % str(e))
        except Exception as e:
            error_message = f"Unexpected error: {str(e)}"
            self.log_request(request_data, {}, 'error', error_message)
            raise UserError(_('Unexpected error: %s') % str(e))
    
    def get_embeddings(self, text: str, model: str = None) -> List[float]:
        """Get embeddings using Anthropic Claude's embedding API."""
        if not model:
            model = 'claude-3-sonnet-20240229'  # Default Claude model for embeddings
        
        request_data = {
            'model': model,
            'input': text,
        }
        
        try:
            # Make API request
            headers = {
                'x-api-key': self.get_api_key(),
                'Content-Type': 'application/json',
                'anthropic-version': '2023-06-01',
            }
            
            response = requests.post(
                f"{self.get_base_url()}/embeddings",
                headers=headers,
                json=request_data,
                timeout=30
            )
            
            # Handle rate limits
            self.handle_rate_limits(response)
            
            if response.status_code == 200:
                response_data = response.json()
                embeddings = response_data['embedding']
                
                # Log successful request
                self.log_request(request_data, response_data, 'success')
                
                return embeddings
            else:
                error_data = response.json() if response.content else {}
                error_message = error_data.get('error', {}).get('message', f'HTTP {response.status_code}')
                
                # Log failed request
                self.log_request(request_data, error_data, 'error', error_message)
                
                raise UserError(_('Claude API error: %s') % error_message)
                
        except requests.exceptions.RequestException as e:
            error_message = f"Network error: {str(e)}"
            self.log_request(request_data, {}, 'error', error_message)
            raise UserError(_('Network error: %s') % str(e))
        except Exception as e:
            error_message = f"Unexpected error: {str(e)}"
            self.log_request(request_data, {}, 'error', error_message)
            raise UserError(_('Unexpected error: %s') % str(e))
    
    def stream_response(self, prompt: str, model: str = None, **kwargs):
        """Stream response from Anthropic Claude."""
        if not model:
            model = self.get_default_model()
        
        # Validate parameters
        validated_params = self.validate_parameters(**kwargs)
        validated_params['stream'] = True
        
        # Prepare request data for streaming
        request_data = {
            'model': model,
            'max_tokens': validated_params.get('max_tokens', 1000),
            'messages': [{
                'role': 'user',
                'content': prompt
            }],
            'stream': True
        }
        
        # Map parameters to Claude format
        if 'temperature' in validated_params:
            request_data['temperature'] = validated_params['temperature']
        if 'top_p' in validated_params:
            request_data['top_p'] = validated_params['top_p']
        if 'stop_sequences' in validated_params:
            request_data['stop_sequences'] = validated_params['stop_sequences']
        
        try:
            # Make streaming API request
            headers = {
                'x-api-key': self.get_api_key(),
                'Content-Type': 'application/json',
                'anthropic-version': '2023-06-01',
            }
            
            response = requests.post(
                f"{self.get_base_url()}/messages",
                headers=headers,
                json=request_data,
                timeout=30,
                stream=True
            )
            
            if response.status_code == 200:
                for line in response.iter_lines():
                    if line:
                        line = line.decode('utf-8')
                        if line.startswith('data: '):
                            data = line[6:]  # Remove 'data: ' prefix
                            if data == '[DONE]':
                                break
                            try:
                                chunk = json.loads(data)
                                if 'type' in chunk and chunk['type'] == 'content_block_delta':
                                    if 'delta' in chunk and 'text' in chunk['delta']:
                                        text = chunk['delta']['text']
                                        if text:
                                            yield text
                            except json.JSONDecodeError:
                                continue
            else:
                error_data = response.json() if response.content else {}
                error_message = error_data.get('error', {}).get('message', f'HTTP {response.status_code}')
                raise UserError(_('Claude API error: %s') % error_message)
                
        except requests.exceptions.RequestException as e:
            raise UserError(_('Network error: %s') % str(e))
        except Exception as e:
            raise UserError(_('Unexpected error: %s') % str(e))
    
    def call_function(self, function_name: str, arguments: Dict) -> Any:
        """Call a function using Claude's function calling feature."""
        # This would be implemented with the function calling framework
        # For now, return a placeholder
        return f"Function {function_name} called with arguments: {arguments}"
    
    def get_available_functions(self) -> List[Dict]:
        """Get list of available functions for Claude."""
        # This would return the registered function schemas
        return [] 